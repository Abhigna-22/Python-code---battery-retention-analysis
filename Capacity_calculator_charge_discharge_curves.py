# -*- coding: utf-8 -*-
"""final Python code for calculating capacity.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mee89pZ4Wj9-5S46YhoDeRdaaEvfuP-x
"""

from google.colab import files
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import savgol_filter, argrelextrema

# === Upload CSV ===
uploaded = files.upload()   # user selects file manually
filename = list(uploaded.keys())[0]   # get the uploaded filename

# === Read CSV (skip header junk lines) ===
# Inspect the first few lines of the uploaded file to determine the correct skiprows and header.
# You might need to adjust skiprows based on the actual file content.
# Assuming the first row after skipping contains the actual column names 'Time/sec' and 'Potential/V'
df = pd.read_csv(filename, skiprows=21)


# === Clean column names ===
# Check if the expected columns exist after reading the CSV
if 'Time/sec' in df.columns and 'Potential/V' in df.columns:
    df.columns = df.columns.str.strip()
    df.rename(columns={'Time/sec': 'time', 'Potential/V': 'voltage'}, inplace=True)
elif df.shape[1] >= 2:
    # If the expected column names are not found, assume the first two columns are time and voltage
    print("Expected column names not found. Assuming first two columns are 'Time/sec' and 'Potential/V'.")
    df.columns = ['Time/sec', 'Potential/V']
    df.columns = df.columns.str.strip()
    df.rename(columns={'Time/sec': 'time', 'Potential/V': 'voltage'}, inplace=True)

else:
    raise ValueError("Could not find 'Time/sec' and 'Potential/V' columns or enough columns in the CSV file.")


# === Drop duplicate rows ===
df = df.drop_duplicates()
# Check if 'time' column exists before dropping duplicates based on it
if 'time' in df.columns:
    df = df.drop_duplicates(subset=["time"], keep="first")   # ensure unique timestamps
else:
    print("Warning: 'time' column not found after renaming. Skipping dropping duplicates based on time.")
df = df.reset_index(drop=True)

time = df['time'].values
voltage = df['voltage'].values

# === Smoothen the voltage data ===
# Apply a Savitzky-Golay filter to smoothen the voltage data
# Adjust window_length and polyorder as needed based on your data's noise level and signal characteristics
# window_length must be odd and greater than polyorder
window_length = 5  # Example: choose an appropriate window length
polyorder = 3       # Example: choose an appropriate polynomial order
smoothed_voltage = savgol_filter(voltage, window_length, polyorder)


# === Find transition points (local maxima and minima) ===
# Find indices of local maxima and minima
maxima_indices = argrelextrema(smoothed_voltage, np.greater)[0]
minima_indices = argrelextrema(smoothed_voltage, np.less)[0]

# Combine and sort the indices
transition_indices = np.sort(np.concatenate([maxima_indices, minima_indices]))

# Filter out transition points that are too close to each other
# This helps to avoid picking up multiple points for a single transition
min_distance_between_transitions = 50 # Example: minimum number of data points between transitions
filtered_transitions = []
if len(transition_indices) > 0:
    filtered_transitions.append(transition_indices[0])
    for i in range(1, len(transition_indices)):
        if transition_indices[i] - filtered_transitions[-1] > min_distance_between_transitions:
            filtered_transitions.append(transition_indices[i])

transition_indices = np.array(filtered_transitions)


cycles = []
cycle_num = 1

# === Loop over cycles ===
# The first point can be either a charge or discharge start, depending on the initial state
# We'll assume the first identified transition point marks the start of the first half-cycle
if len(transition_indices) > 1:
    start_index = 0
    for i in range(0, len(transition_indices) - 1, 2):
        # Determine if the current segment is charging or discharging
        # Look at the direction of voltage change within the segment
        segment_start_index = transition_indices[i]
        segment_end_index = transition_indices[i+1]

        # Check the voltage change between start and end of the segment
        is_charging = smoothed_voltage[segment_end_index] > smoothed_voltage[segment_start_index]

        if is_charging:
            charge_start = time[transition_indices[i]]
            charge_end = time[transition_indices[i+1]]
            discharge_start = time[transition_indices[i+1]]
            if i + 2 < len(transition_indices):
                discharge_end = time[transition_indices[i+2]]
            else:
                discharge_end = time[-1] # take last recorded time

            charging_time = charge_end - charge_start
            discharging_time = discharge_end - discharge_start if discharge_end else np.nan

        else: # Discharging
            discharge_start = time[transition_indices[i]]
            discharge_end = time[transition_indices[i+1]]
            charge_start = time[transition_indices[i+1]]
            if i + 2 < len(transition_indices):
                 charge_end = time[transition_indices[i+2]]
            else:
                 charge_end = time[-1] # take last recorded time

            discharging_time = discharge_end - discharge_start
            charging_time = charge_end - charge_start if charge_end else np.nan


        cycles.append([
            cycle_num,
            charging_time,
            discharging_time,
            charge_start,
            charge_end,
            discharge_start,
            discharge_end
        ])
        cycle_num += 1

    # Handle the last half-cycle if it exists
    if len(transition_indices) % 2 != 0:
        last_half_cycle_start_index = transition_indices[-1]
        # Determine if the last segment is charging or discharging
        # Compare the voltage at the last transition point with the voltage at the very end of the data
        if last_half_cycle_start_index < len(smoothed_voltage) - 1:
             is_charging_last = smoothed_voltage[-1] > smoothed_voltage[last_half_cycle_start_index]
        else:
            # If the last transition is the very last point, we can't determine the next state.
            # We'll assume it's the end of a full cycle for simplicity or handle as a partial cycle.
            # For now, let's assume it's the end of the last discharge cycle.
            is_charging_last = False


        if is_charging_last:
            charge_start = time[last_half_cycle_start_index]
            charge_end = time[-1] # Ends at the end of the data
            charging_time = charge_end - charge_start
            cycles.append([
                cycle_num,
                charging_time,
                np.nan, # No discharge time for the last half-cycle
                charge_start,
                charge_end,
                charge_end, # Discharge_Start_Time (same as Charge_End_Time)
                np.nan # No discharge end time
            ])
        else: # Discharging
            discharge_start = time[last_half_cycle_start_index]
            discharge_end = time[-1] # Ends at the end of the data
            discharging_time = discharge_end - discharge_start
            cycles.append([
                cycle_num,
                np.nan, # No charging time for the last half-cycle
                discharging_time,
                discharge_end, # Charge_Start_Time (same as Discharge_End_Time)
                np.nan, # No charge end time
                discharge_start,
                discharge_end
            ])
        cycle_num += 1



results = pd.DataFrame(cycles, columns=[
    'Cycle',
    'Charging_Time',
    'Discharging_Time',
    'Charge_Start_Time',
    'Charge_End_Time',
    'Discharge_Start_Time',
    'Discharge_End_Time'
])

# === Approximate sub-1s durations as zero ===
results['Charging_Time'] = results['Charging_Time'].apply(lambda x: 0 if pd.notna(x) and x < 1 else x)
results['Discharging_Time'] = results['Discharging_Time'].apply(lambda x: 0 if pd.notna(x) and x < 1 else x)

# === Drop useless rows (both charge and discharge = 0) ===
cleaned = results[~((results['Charging_Time'] == 0) & (results['Discharging_Time'] == 0))].copy()

# === Reset index and reassign continuous cycle numbers ===
cleaned.reset_index(drop=True, inplace=True)
cleaned['Cycle'] = cleaned.index + 1

# Print preview
print(cleaned.head(20))
########################################################################


# Plot the voltage data
plt.figure(figsize=(12, 6))
plt.plot(time, voltage, label='Original Voltage', alpha=0.5) # Plot original voltage with transparency
plt.plot(time, smoothed_voltage, label='Smoothed Voltage') # Plot smoothed voltage

# Mark the transition points
# transition_indices is a list of indices in the time/voltage arrays
transition_times = time[transition_indices]
transition_voltages = voltage[transition_indices] # Use original voltage for plotting transition points

plt.scatter(transition_times, transition_voltages, color='red', marker='o', label='Transition Points')

plt.xlabel('Time (sec)')
plt.ylabel('Voltage (V)')
plt.title('Voltage vs Time with Transition Points (Derivative with Step)')
plt.legend()
plt.grid(True)
plt.show()


# Plot Charging_Time vs Cycle
plt.figure(figsize=(12, 6))
plt.plot(cleaned['Cycle'], cleaned['Charging_Time'], label='Charging Time')

# Plot Discharging_Time vs Cycle
plt.plot(cleaned['Cycle'], cleaned['Discharging_Time'], label='Discharging Time')

plt.xlabel('Cycle Number')
plt.ylabel('Time (sec)')
plt.title('Charging and Discharging Time vs Cycle Number')
plt.legend()
plt.grid(True)
plt.show()

"""# Task
Calculate and plot the charging and discharging capacity vs. cycle number from the provided GCD data. The capacity should be calculated using the formula: Capacity (mAh/g) = (Current Density * Time) / 3.6, where Time is the charging or discharging time in seconds. Save the results to an Excel file and display the plot.

## Get current density

### Subtask:
Prompt the user to input the current density used in the experiment.

**Reasoning**:
Prompt the user to input the current density and convert it to a float.
"""

current_density_str = input("Please enter the current density in A/g: ")
current_density = float(current_density_str)

"""## Calculate capacity

### Subtask:
Calculate the charging and discharging capacity for each cycle using the provided formula and the user's input for current density.

**Reasoning**:
Calculate the charging and discharging capacity for each cycle using the provided formula and the `cleaned` DataFrame.
"""

voltage_series = pd.Series(smoothed_voltage, index=time)

# Calculate start and end voltages for charging
cleaned['Charge_Start_Voltage'] = cleaned['Charge_Start_Time'].map(voltage_series)
cleaned['Charge_End_Voltage'] = cleaned['Charge_End_Time'].map(voltage_series)
cleaned['Delta_V_Charge'] = cleaned['Charge_End_Voltage'] - cleaned['Charge_Start_Voltage']

# Calculate start and end voltages for discharging
cleaned['Discharge_Start_Voltage'] = cleaned['Discharge_Start_Time'].map(voltage_series)
cleaned['Discharge_End_Voltage'] = cleaned['Discharge_End_Time'].map(voltage_series)
cleaned['Delta_V_Discharge'] = cleaned['Discharge_End_Voltage'] - cleaned['Discharge_Start_Voltage']

# Calculate Charging and Discharging Capacity in F/g
# Formula: C (F/g) = (Current Density (A/g) * Time (s)) / |Delta_V (V)|
# Handle cases where Delta_V is zero to avoid division by zero, resulting in NaN capacity.
# Use 1e-6 as a small threshold for checking if Delta_V is effectively zero.
cleaned['Charging_Capacity'] = np.where(
    (cleaned['Delta_V_Charge'].abs() > 1e-6) & (cleaned['Charging_Time'].notna()),
    (current_density * cleaned['Charging_Time']) / cleaned['Delta_V_Charge'].abs(),
    np.nan
)
cleaned['Discharging_Capacity'] = np.where(
    (cleaned['Delta_V_Discharge'].abs() > 1e-6) & (cleaned['Discharging_Time'].notna()),
    (current_density * cleaned['Discharging_Time']) / cleaned['Delta_V_Discharge'].abs(),
    np.nan
)

display(cleaned.head())

current_density_str = input("Please enter the current density in A/g: ")
current_density = float(current_density_str)

# Calculate coulombic efficiency (Discharging Capacity / Charging Capacity) * 100
# Handle cases where Charging Capacity is 0 or NaN to avoid division by zero
cleaned['Coulombic_Efficiency (%)'] = np.where(
    cleaned['Charging_Capacity'].notna() & (cleaned['Charging_Capacity'] > 0),
    (cleaned['Discharging_Capacity'] / cleaned['Charging_Capacity']) * 100,
    np.nan # If charging capacity is 0 or NaN, efficiency is NaN
)

display(cleaned.head())

# Create a new DataFrame with Cycle, Charging_Capacity, Discharging_Capacity, and Coulombic_Efficiency
# The capacity columns now represent F/g.
capacity_results = cleaned[['Cycle', 'Charging_Capacity', 'Discharging_Capacity', 'Coulombic_Efficiency (%)']].copy()

# Get user input for the Excel file name
output_excel_file = input("Please enter the desired name for the Excel file (e.g., my_capacity_data.xlsx): ")

# Save the results to an Excel file
capacity_results.to_excel(output_excel_file, index=False)

print(f"Capacity results (in F/g) saved to {output_excel_file}")

# Plot Charging_Capacity, Discharging_Capacity, and Coulombic_Efficiency vs Cycle
fig, ax1 = plt.subplots(figsize=(12, 6))

# Plot Charging and Discharging Capacity (in F/g) on the primary y-axis
ax1.plot(cleaned['Cycle'], cleaned['Charging_Capacity'], label='Charging Capacity (F/g)', color='blue')
ax1.plot(cleaned['Cycle'], cleaned['Discharging_Capacity'], label='Discharging Capacity (F/g)', color='red')
ax1.set_xlabel('Cycle Number')
ax1.set_ylabel('Capacity (F/g)', color='black') # Updated y-axis label
ax1.tick_params(axis='y', labelcolor='black')
ax1.grid(True)

# Create a secondary y-axis for Coulombic Efficiency
ax2 = ax1.twinx()
ax2.plot(cleaned['Cycle'], cleaned['Coulombic_Efficiency (%)'], label='Coulombic Efficiency (%)', color='green', linestyle='--')
ax2.set_ylabel('Coulombic Efficiency (%)', color='green')
ax2.tick_params(axis='y', labelcolor='green')

# Add a title and legend
plt.title('Charging and Discharging Capacity (F/g) and Coulombic Efficiency vs Cycle Number') # Updated title
fig.legend(loc="upper right", bbox_to_anchor=(1,1), bbox_transform=ax1.transAxes)

plt.show()
